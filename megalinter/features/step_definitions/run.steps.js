"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const cucumber_1 = require("@cucumber/cucumber");
const sinon = __importStar(require("sinon"));
const tl = __importStar(require("azure-pipelines-task-lib/task"));
const megalinter_1 = require("../../megalinter");
let result = null;
let errorOccurred = false;
// Lint changed files only test state
let validateAllCodebaseSet = false;
let validateAllCodebaseValue = "";
// Docker caching test state
let dockerImagePulled = false;
let dockerImageLoadedFromCache = false;
let dockerImageSavedToCache = false;
let dockerCacheTarballExists = false;
let dockerImageAvailable = false;
let sandbox;
let getInputStub;
let getBoolInputStub;
let existStub;
let npxExecCalled = false;
from;
"assert";
impisimport * as;
sinon;
from;
"sinon";
leimport * as;
tl;
from;
"azure-pip";
timport;
{
    megalinter_1.run;
}
from;
"../tring) => {;
const mockToo;
let result = null;
letxt - let;
errorOccurred: boolean = falci;
// Lint changed files only test sllslet validateAllCodebaseSet: boolean ollet validateAllCodebaseValue: string = "";
// Docker caching test state
let dockerI, let, dockerImagePulled, let;
do
    ;
while (dockerImageAvailablelet);
dockerImageSavedToCache: boolean = false;
lvelet;
dockerCacheTarballExists: boolean = falstrlet;
dockerImageAvailable: boolean = false;
l;
let sandbox;
let get, let, getInputStub, tlet, getBoolInputStub;
let existStub;
let n, let, npxExecCalled = fyp; // esliimport { Given, When, Then,  import * as assert from "assert";
Opimport * ations;
npxEximport * as;
sinon;
from;
" };
return 0;
impisimport * as;
sinon;
from;
"sneleimport * as tl from ";
azure - pip;
"tisu    const mockToo;
let result = null;
letxt - let;
errorOtllet;
result: sturnsletxt - let;
errorOccurred: booleansa; // Li.stub(tl, "exist").callsFake(() => d  
// Docker caching test state
let dockerI, let, dockerImagePulled, let;
do
    ;
while (dockerImageAvailablegs / );
let dockerI, let, dockerIma, dockerImageAvailablelet, dockerImageSa;
lvelet;
dockerCacheTarballExists: boolean = falstrlet;
dockerImageAvailable: brn;
l;
let sandbox;
let get, let, getInputStub, tlet, getBo, le, let, get, let, getInputStub, r, let, existStub;
let n, let, npxExecCalled;
let n, let, npxExecCalandbox, stub;
(tl, "geimport * as sinon from ");
sinon;
";;
Opimport * ations;
nptSimporeturns(false);
getInputSOpimport * ations;
npxEximport;
t;
")          npxEximwi        return 0;;
impisimport;
lt;
impisiOcimpisimp;
flet;
result: string | null;
null;
letxt - let;
errorOtllet;
result: sturnsletxt - lekerImageSletxt - let;
errorOtllet;
result: stll; // Docker caching test state
let dockerI, let, dockerImagePulled, let;
do
    ;
while (dockerImageAvailablethlet);
dockerI;
let dockerImad;
"            dockerImageAvailablegs/: let dockerI ;;
lvelet;
dockerCacheTarballExists: boolean = falstrlet;
dockerImageAvailable: brn;
l;
let sandbox;
let sandbox;
let get, lettStub, withArgs;
("cacheDockerImage");
let get, let, getInputStub, n, let, npxExecCalled;
let n, let, npxExecCalandbox, stub;
(tl, "geimport * as sinon from ");
sinon;
";;
Opimport * ations;
nptSimporeturns(false);
naOpimport * atiunction();
{
    getBoolInputStu;
    nptSimpha;
    getInputSOpimport * ations;
    ;
    npxEximport;
    t;
    ")   nl      }),;
    impisimport;
    lt;
}
impisiOcimpisimp;
flet;
resurgs("lintChaimpisiOcimpisimp flet s(letxt-let errorven(", no, cached, docker, image, tarball, elet, dockerI, let, dockerImagePulled, boole, let);
do
    ;
while (dockerImageAvailablethlet);
dockerI;
let dockerImad;
" a            dockerImageAvailablethlet dockerI   lru lvelet dockerCacheTarballExists: boolean = falstrlet dockerImageAvailable: brn;
l;
let sandbox;
let sandbox;
let sandbox;
let gnslenvlet, sandbox;
lOplet;
get;
lettStub.withArgs("ca_Aimport * a==import * as sinogeimport * a==import * as sinon from ", sinon, ";, Opimport * ations);
nptSimporeturns(false);
naOpimport * atiunctionidateAllCodebaseSet;
false;
Opimport * ations;
nptSimporeturns(false);
naOpimport * aties;
nptSimpro;
naOpimport * atiunction();
Error;
getBoolInputStu;
np;
e;
getInputSOpimnknown;
error;
occurred;
" );;
npxEximport;
t;
"ct  n impisimport lt      }),;
impisiOcimpisincimpisiOcimpisimp;
flet;
dockerImageAvailablethlet;
dockerI;
let dockerImad;
" a            dockerImageAvailablethlet dockerI   lru lvelet dockerCacheTarballExists: boolean = falThl));
let sandbox;
let sandbox;
let sandbox;
let gnslenvlet, sandbox;
lOplet;
get;
lettStub.withArgs("ca_Aimport (", the, let, sandbox, ("docker image cachorlet sandbox: sinon.SinonSandbox;), lstlet, gnsle(result, "Test lOplet get   lettStub.withArgs(", cn, to, fail, wOpimport * ations));
nptSimporeturns(false);
naOpimport * atiunctionidateAllCodebaseSet;
false;
(nptSimpct);
naOpimport * atiunctionidateA;
tOpimport * ations;
nptSimporeturns(false);
t.;
",;
;
naOpimport * aties;
nld;
naOpimport * atiunction();
Error;
ge();
npxEximport;
t;
"ct  n impisimport lt      }),;
impisiOcimpisincimpisiOcimpisimp;
flet;
edimpisiOcimpisincimpisiOcimpisimp;
;
(0, cucumber_1.Then)("the docke             dockerImageAvailablethle flet sandbox: (", docker, image, esl);
let sandbox;
let sandbox;
let gnslenvlet, sandbox;
lOplet;
get;
lettStubhelet;
sandboage;
should;
not;
be;
pulledlet;
sandbox: sinon.SinonSandbox;
lualet;
gnslockerImagePulled,
    fallOplet;
get;
lettStub.withArgs("ca_Aimportbelstlet gnsle(, result, "Test lOplet get   lettStub.withArgs(", cn, to, fail, wOpimport * ations);
nptSil(result, ma, "Test ac          nptSimporeturns(false);, naOpimport * all, to, be, saved, but, one, naOpimport * atiunctionidateA_AL(nptSimpct, naOpimport * atiunctionidatese, naOpimport * atiunss, nptSimporeturns(false)));
t.;
",;
ue;
;
naOpimport * aties;
ASE;
to;
be;
set;
i;
he;
impisiOcimpisincimpisiOcimpisimp;
flet;
edimpisiOcimpisincimpisiOcimpisimp;
;
(0, cucumber_1.Then)("the docke             dockerIte           edimpisiOcimpisincimpisiOc'f});, (0, cucumber_1.Then)("the docke             dockerImageAas, Talulet, sandbox, ("docker image cachl))), let, sandbox, sinon.SinonSandbox));
let gnslenvlet, sas, let, sandbox, capturelet, gnslenvlet, sandbox, lOplet, get, lettStubhelet, sandboage, shoul;
",lualet gnslockerImagePulled,;
fallOplet;
get;
lettStub.withArgs("ca_Aimportbelstlet g b    fallOplet get   lettStuTh    result,, "Test lOplet get   lettStub.withArgs(", cn, to, fait, "    ", Test(nptSil(result, ma, "Test ac          nptSimporeturns(faxpma    ", Test, ac, npt, t, naOpimport * all, to, be, saved, but, one, naOp, b, naOpimport * atiunctionidateA_AL(All, naOpimport * atiunctionida.ok(npxExecCalled, ue)))));
naOpimport * aties;
it;
was;
not.;
",;
;
;
