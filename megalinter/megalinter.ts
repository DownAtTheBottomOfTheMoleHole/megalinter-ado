// Import the Azure Pipelines Task Library
import tl = require("azure-pipelines-task-lib/task");
import tr = require("azure-pipelines-task-lib/toolrunner");
import * as https from "https";
import * as http from "http";

// PR description template for fix PRs
const PR_DESCRIPTION_TEMPLATE = `# What?

Automated code fixes applied by MegaLinter during CI/CD pipeline run.

This pull request contains formatting and linting fixes that were automatically generated by MegaLinter's auto-fix feature.

# Why?

To maintain consistent code quality and formatting standards across the codebase.

# How?

MegaLinter was run with the \`--fix\` flag enabled, which automatically applies fixes for supported linters including:
- Code formatters (Prettier, Black, etc.)
- Linting auto-fixes (ESLint, Pylint, etc.)
- Markdown formatting
- YAML/JSON formatting

# Related

- Pipeline Run: [Build $(Build.BuildId)]($(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId))
- Source Branch: \`$(Build.SourceBranch)\`

# Testing?

All fixes have been validated by MegaLinter. Please review the changes to ensure they meet project standards.

## Checklist

- [x] My code follows the style guidelines of this project.
- [x] I have performed a self-review of my own code.
- [ ] I have commented my code, particularly in hard-to-understand areas.
- [ ] I have added tests to cover my change(s).
- [ ] All new and existing tests passed.
- [ ] I have made corresponding changes to the documentation.

# Anything Else?

These are automated fixes. Please review carefully before merging.
`;

/**
 * Creates a pull request in Azure DevOps with the MegaLinter fixes
 */
async function createFixPullRequest(
  sourceBranch: string,
  targetBranch: string,
  title: string,
  description: string,
): Promise<boolean> {
  const collectionUri = tl.getVariable("System.CollectionUri");
  const project = tl.getVariable("System.TeamProject");
  const repositoryId = tl.getVariable("Build.Repository.ID");
  const accessToken = tl.getVariable("System.AccessToken");

  if (!collectionUri || !project || !repositoryId || !accessToken) {
    console.log("Missing required Azure DevOps variables for PR creation");
    return false;
  }

  // Build the API URL
  const apiUrl = `${collectionUri}${project}/_apis/git/repositories/${repositoryId}/pullrequests?api-version=7.1`;

  const prPayload = {
    sourceRefName: `refs/heads/${sourceBranch}`,
    targetRefName: `refs/heads/${targetBranch}`,
    title: title,
    description: description,
    isDraft: false,
  };

  return new Promise((resolve) => {
    try {
      const url = new URL(apiUrl);
      const options: https.RequestOptions = {
        hostname: url.hostname,
        path: url.pathname + url.search,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${accessToken}`,
        },
      };

      const req = (url.protocol === "https:" ? https : http).request(
        options,
        (res) => {
          let data = "";
          res.on("data", (chunk) => (data += chunk));
          res.on("end", () => {
            if (res.statusCode === 201) {
              const pr = JSON.parse(data);
              console.log(`✅ Pull request created: ${pr.url}`);
              console.log(`   PR #${pr.pullRequestId}: ${pr.title}`);
              resolve(true);
            } else {
              console.log(`Failed to create PR: ${res.statusCode} - ${data}`);
              resolve(false);
            }
          });
        },
      );

      req.on("error", (err) => {
        console.log(`Error creating PR: ${err.message}`);
        resolve(false);
      });

      req.write(JSON.stringify(prPayload));
      req.end();
    } catch (err) {
      console.log(`Exception creating PR: ${err}`);
      resolve(false);
    }
  });
}

/**
 * Commits and pushes MegaLinter fixes to a new branch and creates a PR
 */
async function handleFixPullRequest(
  workingDir: string,
  isPullRequest: boolean,
): Promise<void> {
  console.log("Starting handleFixPullRequest with workingDir:", workingDir);
  const createPR = tl.getBoolInput("createFixPR");
  console.log("createFixPR input:", createPR);
  if (!createPR) {
    console.log("createFixPR is false, skipping PR creation");
    return;
  }

  if (isPullRequest) {
    console.log(
      "Pull request build detected - skipping fix PR creation as fixes are applied to the PR branch",
    );
    return;
  }

  // Check if there are any changes to commit
  console.log("Checking for git changes in:", workingDir);
  const statusResult = tl.execSync("git", ["status", "--porcelain"], {
    cwd: workingDir,
  });
  console.log(
    "Git status result - code:",
    statusResult.code,
    "stdout:",
    statusResult.stdout,
    "stderr:",
    statusResult.stderr,
  );

  if (!statusResult.stdout || !statusResult.stdout.trim()) {
    console.log("No fixes to commit - working directory is clean");
    return;
  }

  console.log("MegaLinter fixes detected, creating pull request...");

  // Get required variables for authentication
  const collectionUri = tl.getVariable("System.CollectionUri");
  const project = tl.getVariable("System.TeamProject");
  const repoName = tl.getVariable("Build.Repository.Name");
  const accessToken = tl.getVariable("System.AccessToken");

  // Validate required variables
  if (!collectionUri || !project || !repoName || !accessToken) {
    console.error(
      "❌ Missing required Azure DevOps variables. Ensure System.AccessToken is enabled.",
    );
    console.error("Required variables:");
    console.error(`  - System.CollectionUri: ${collectionUri ? "✓" : "✗"}`);
    console.error(`  - System.TeamProject: ${project ? "✓" : "✗"}`);
    console.error(`  - Build.Repository.Name: ${repoName ? "✓" : "✗"}`);
    console.error(`  - System.AccessToken: ${accessToken ? "✓" : "✗"}`);
    return;
  }

  // Get branch info
  const sourceBranch = tl.getVariable("Build.SourceBranch") || "";
  const sourceBranchName = sourceBranch.replace("refs/heads/", "");
  const buildId = tl.getVariable("Build.BuildId") || Date.now().toString();
  const fixBranchName = `fix/megalinter-${buildId}`;

  // Configure git
  tl.execSync("git", ["config", "user.email", "megalinter@azure-pipelines"], {
    cwd: workingDir,
  });
  tl.execSync("git", ["config", "user.name", "MegaLinter"], {
    cwd: workingDir,
  });

  // Create and checkout fix branch
  const checkoutResult = tl.execSync("git", ["checkout", "-b", fixBranchName], {
    cwd: workingDir,
  });

  if (checkoutResult.code !== 0) {
    console.log(`Failed to create fix branch: ${checkoutResult.stderr}`);
    return;
  }

  // Stage all changes
  tl.execSync("git", ["add", "-A"], { cwd: workingDir });

  // Commit with conventional commit message
  const commitMessage = "fix(lint): apply MegaLinter auto-fixes";
  const commitResult = tl.execSync("git", ["commit", "-m", commitMessage], {
    cwd: workingDir,
  });

  if (commitResult.code !== 0) {
    console.log(`Failed to commit fixes: ${commitResult.stderr}`);
    return;
  }

  // Set authenticated remote URL for push
  // First, save the original remote URL to restore it later
  let originalRemoteUrl = "";
  try {
    const getRemoteResult = tl.execSync(
      "git",
      ["remote", "get-url", "origin"],
      {
        cwd: workingDir,
      },
    );
    originalRemoteUrl =
      getRemoteResult.code === 0 ? getRemoteResult.stdout.trim() : "";
  } catch {
    console.warn(
      "Warning: Could not retrieve original git remote URL. Aborting fix PR creation to avoid persisting credentials in .git/config.",
    );
    return;
  }

  if (!originalRemoteUrl) {
    console.warn(
      "Warning: Original git remote URL is empty or unavailable. Aborting fix PR creation to avoid persisting credentials in .git/config.",
    );
    return;
  }

  const baseUrl = collectionUri.replace(
    /^https:\/\//,
    `https://${accessToken}@`,
  );
  const gitUrl = `${baseUrl}${project}/_git/${repoName}`;
  tl.execSync("git", ["remote", "set-url", "origin", gitUrl], {
    cwd: workingDir,
  });

  // Push the branch
  const pushResult = tl.execSync(
    "git",
    ["push", "-u", "origin", fixBranchName],
    { cwd: workingDir },
  );

  // Restore the original remote URL to avoid persisting the token in .git/config
  if (originalRemoteUrl) {
    try {
      tl.execSync("git", ["remote", "set-url", "origin", originalRemoteUrl], {
        cwd: workingDir,
      });
      console.log("✅ Restored original git remote URL (token cleaned up)");
    } catch (err) {
      console.error(
        "❌ Failed to restore original git remote URL. Token may persist in .git/config!",
      );
      if (err instanceof Error) {
        console.error(`Error: ${err.message}`);
      }
    }
  }

  if (pushResult.code !== 0) {
    console.log(`Failed to push fix branch: ${pushResult.stderr}`);
    return;
  }

  console.log(`✅ Pushed fixes to branch: ${fixBranchName}`);

  // Create the pull request
  const prTitle = "fix(lint): apply MegaLinter auto-fixes"; // 41 chars, under 72

  // Replace variables in description
  let prDescription = PR_DESCRIPTION_TEMPLATE.replace(
    /\$\(Build\.BuildId\)/g,
    buildId,
  )
    .replace(
      /\$\(System\.CollectionUri\)/g,
      tl.getVariable("System.CollectionUri") || "",
    )
    .replace(
      /\$\(System\.TeamProject\)/g,
      tl.getVariable("System.TeamProject") || "",
    )
    .replace(/\$\(Build\.SourceBranch\)/g, sourceBranch);

  // Ensure description is under 4000 characters
  if (prDescription.length > 4000) {
    prDescription = prDescription.substring(0, 3997) + "...";
  }

  await createFixPullRequest(
    fixBranchName,
    sourceBranchName,
    prTitle,
    prDescription,
  );

  console.log(
    `Attempted to create PR from '${fixBranchName}' to '${sourceBranchName}'`,
  );
}

// Define an asynchronous function named 'run' with a return type of Promise<void>
export async function run(): Promise<void> {
  try {
    // Get key configuration inputs first
    const flavor = tl.getInput("flavor") || "all";
    const release = tl.getInput("release") || "latest";
    const runnerVersion = tl.getInput("runnerVersion") || "latest";
    const customImage = tl.getInput("image");
    const workingDir =
      tl.getVariable("Build.SourcesDirectory") ||
      tl.getInput("path") ||
      tl.getVariable("Pipeline.Workspace") ||
      ".";

    // Check if this is a pull request build
    const buildReason = tl.getVariable("Build.Reason");
    const isPullRequest = buildReason === "PullRequest";

    // Get PR comment reporter setting (defaults to true for PR builds)
    const enablePRComments = tl.getBoolInput("enablePRComments");
    const shouldEnablePRComments = enablePRComments || isPullRequest;

    if (isPullRequest) {
      console.log("Pull Request build detected - PR comments will be enabled");
    }

    // Determine the full Docker image name with tag
    let dockerImageName: string;
    if (customImage) {
      // User provided a custom image override
      dockerImageName = customImage;
    } else {
      // Build image name from flavor and release
      dockerImageName = "oxsecurity/megalinter";
      if (flavor && flavor !== "all") {
        dockerImageName += `-${flavor}`;
      }
      dockerImageName += `:${release}`;
    }

    console.log(`Using Docker image: ${dockerImageName}`);

    // Define string input parameters that map to mega-linter-runner CLI args
    // Note: input names must match task.json exactly (camelCase)
    const stringInputMappings: { input: string; cliArg: string }[] = [
      { input: "path", cliArg: "--path" },
      { input: "flavor", cliArg: "--flavor" },
      { input: "image", cliArg: "--image" },
      { input: "env", cliArg: "--env" },
      { input: "release", cliArg: "--release" },
      { input: "containerName", cliArg: "--container-name" },
    ];

    // Define boolean input parameters
    // Note: input names must match task.json exactly (camelCase)
    const boolInputMappings: { input: string; cliArg: string }[] = [
      { input: "fix", cliArg: "--fix" },
      { input: "help", cliArg: "--help" },
      { input: "install", cliArg: "--install" },
      { input: "removeContainer", cliArg: "--remove-container" },
    ];

    // Build arguments array for mega-linter-runner
    const args: string[] = [];

    // Add string inputs
    stringInputMappings.forEach(({ input, cliArg }) => {
      const value = tl.getInput(input);
      if (value) {
        args.push(cliArg, value);
      }
    });

    // Add boolean inputs
    boolInputMappings.forEach(({ input, cliArg }) => {
      if (tl.getBoolInput(input)) {
        args.push(cliArg);
      }
    });

    // Check if the Docker image is already available in the local Docker cache
    // This helps with caching when using self-hosted agents or Docker layer caching
    const dockerImageCheck = tl.execSync("docker", [
      "images",
      "-q",
      dockerImageName,
    ]);

    if (dockerImageCheck.stdout && dockerImageCheck.stdout.trim()) {
      console.log(
        `Docker image '${dockerImageName}' found in cache. Skipping pull.`,
      );
    } else {
      console.log(`Pulling Docker image: ${dockerImageName}`);

      // Use async exec for streaming output during docker pull
      const dockerTool = tl.tool("docker");
      dockerTool.arg(["pull", dockerImageName]);
      const dockerPullCode = await dockerTool.exec({
        failOnStdErr: false,
        silent: false,
      } as tr.IExecOptions);

      if (dockerPullCode !== 0) {
        tl.setResult(
          tl.TaskResult.Failed,
          `Failed to pull Docker image: ${dockerImageName}`,
        );
        return;
      }
      console.log("Docker image pulled successfully.");
    }

    // Execute mega-linter-runner via npx with streaming output
    const npxPackage =
      runnerVersion === "latest"
        ? "mega-linter-runner"
        : `mega-linter-runner@${runnerVersion}`;

    console.log(`Running: npx ${npxPackage} ${args.join(" ")}`);

    // Build environment variables for the mega-linter-runner process
    const execEnv: { [key: string]: string } = { ...process.env } as {
      [key: string]: string;
    };

    // Enable Azure DevOps PR comment reporter when in PR context
    if (shouldEnablePRComments) {
      console.log("Enabling Azure DevOps PR comment reporter");
      execEnv["AZURE_COMMENT_REPORTER"] = "true";
      execEnv["SYSTEM_ACCESSTOKEN"] =
        tl.getVariable("System.AccessToken") || "";
      execEnv["SYSTEM_COLLECTIONURI"] =
        tl.getVariable("System.CollectionUri") || "";
      execEnv["SYSTEM_TEAMPROJECT"] =
        tl.getVariable("System.TeamProject") || "";
      execEnv["BUILD_BUILD_ID"] = tl.getVariable("Build.BuildId") || "";
      execEnv["BUILD_REPOSITORY_ID"] =
        tl.getVariable("Build.Repository.ID") || "";
    }

    // Set additional MegaLinter configuration from inputs
    const configFile = tl.getInput("configFile");
    if (configFile) {
      execEnv["MEGALINTER_CONFIG"] = configFile;
    }
    const reportsPath = tl.getInput("reportsPath");
    if (reportsPath) {
      execEnv["MEGALINTER_REPORTS_PATH"] = reportsPath;
      console.log(`MegaLinter reports will be saved to: ${reportsPath}`);
    }
    const disableLinters = tl.getInput("disableLinters");
    if (disableLinters) {
      execEnv["DISABLE_LINTERS"] = disableLinters;
    }

    // Use async exec for real-time streaming output
    const npxTool = tl.tool("npx");
    npxTool.arg([npxPackage, ...args]);

    const resultCode = await npxTool.exec({
      failOnStdErr: false,
      silent: false,
      ignoreReturnCode: true,
      env: execEnv,
    } as tr.IExecOptions);

    console.log(`MegaLinter execution completed with exit code: ${resultCode}`);

    // Publish reports as artifact if path is set
    if (reportsPath) {
      console.log(
        `##vso[artifact.upload artifactname=MegaLinterReports;]${reportsPath}`,
      );
    }

    // Handle fix PR creation if fixes were applied
    const fixEnabled = tl.getBoolInput("fix");
    if (fixEnabled) {
      await handleFixPullRequest(workingDir, isPullRequest);
    }

    if (resultCode !== 0) {
      tl.setResult(
        tl.TaskResult.Failed,
        "MegaLinter execution failed with exit code " + resultCode,
      );
    } else {
      tl.setResult(
        tl.TaskResult.Succeeded,
        "MegaLinter completed successfully",
      );
    }
  } catch (err) {
    if (err instanceof Error) {
      tl.setResult(tl.TaskResult.Failed, err.message);
    } else {
      tl.setResult(tl.TaskResult.Failed, "An unknown error occurred");
    }
  }
}

// Call the 'run' function only when executed as the main module
// This allows the module to be imported in tests without auto-executing
if (require.main === module) {
  run();
}
